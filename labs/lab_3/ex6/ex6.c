// DO NOT EDIT THIS FILE

#include <stdio.h>
#include <stddef.h>
#include <stdatomic.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <pthread.h>
#include <semaphore.h>
#include <threads.h>
#include <unistd.h>

#include "restaurant.h"

// Input:
// Space-separated positive integers: n_1, n_2, n_3, n_4, n_5
// For each remaining line of input file, we have any of:
// . - represents the synchronization separator
// Enter <id> <num_people> - Group with this id and number of people requests for a table
// Leave <id> - Group with this id leaves
//
// It may be assumed that all ids are unique.

static void assert_malloc_succeeded(void *ptr) {
    if (!ptr) {
        fprintf(stderr, "Out of memory!\n");
        abort();
    }
}

typedef enum {
    CMD_ENTER,
    CMD_LEAVE
} cmd_type;

struct groupinfo;

typedef struct cmdlist {
    cmd_type type;
    int group_id;
    union {
        struct {
            int group_size;
            bool enqueued;
        } enter_data; // used by type == CMD_ENTER
        struct {
            struct groupinfo *info;
        } leave_data; // used by type == CMD_LEAVE
    };
    struct cmdlist *next;
} cmdlist;

static unsigned cmdlist_size(cmdlist *cmds) {
    unsigned ct = 0;
    while (cmds) {
        cmds = cmds->next;
        ++ct;
    }
    return ct;
}

typedef struct {
    atomic_uint num_ready;
    atomic_bool go;
    atomic_uint num_started;
} busywaiter;

static void busywaiter_init(busywaiter *waiter) {
    atomic_init(&(waiter->num_ready), 0);
    atomic_init(&(waiter->go), false);
    atomic_init(&(waiter->num_started), 0);
}

static void busywaiter_destroy(busywaiter *waiter) {
    (void) waiter;
}

static void busywaiter_group_wait(busywaiter *waiter) {
    atomic_fetch_add_explicit(&(waiter->num_ready), 1, memory_order_acq_rel);
    while (!atomic_load_explicit(&(waiter->go), memory_order_acquire));
    atomic_fetch_add_explicit(&(waiter->num_started), 1, memory_order_acq_rel);
}

static void busywaiter_main_wait(busywaiter *waiter, unsigned num_threads) {
    while (atomic_load_explicit(&(waiter->num_ready), memory_order_acquire) != num_threads);
    atomic_store_explicit(&(waiter->go), true, memory_order_release);
    while (atomic_load_explicit(&(waiter->num_started), memory_order_acquire) != num_threads);
}

typedef struct groupinfo {
    // Set by the main thread
    int group_id;
    int group_size;
    pthread_t thread;
    // for pre-enter spin barrier
    busywaiter *waiter;
    // for on_enqueue() reporting
    bool *enqueue_reporter;
    atomic_uint *enqueue_counter;
    // to tell the main thread that this group is currently eating
    struct groupinfo **eating_list;
    pthread_mutex_t *eating_mutex;

    // Set by the group thread
    int table_id;
    sem_t leave_sem; // to signal to us that it's time to leave
    struct groupinfo *next; // for putting in the eating_list
} groupinfo;

groupinfo *groupinfo_find_and_extract(groupinfo **list, int group_id) {
    while (*list) {
        if ((*list)->group_id == group_id) {
            groupinfo *ret = *list;
            *list = (*list)->next;
            return ret;
        }
        list = &(*list)->next;
    }
    return NULL;
}

thread_local groupinfo *this_thread_info;

static void* run_group(void *context) {
    groupinfo *info = context;
    this_thread_info = info;
    busywaiter_group_wait(info->waiter);
    group_state state;
    info->table_id = request_for_table(&state, info->group_size);
    sem_init(&info->leave_sem, 0, 0);
    pthread_mutex_lock(info->eating_mutex);
    info->next = *(info->eating_list);
    *(info->eating_list) = info;
    pthread_mutex_unlock(info->eating_mutex);
    sem_wait(&info->leave_sem);
    sem_destroy(&info->leave_sem);
    busywaiter_group_wait(info->waiter);
    leave_table(&state);
    return NULL;
}

void on_enqueue(void) {
    groupinfo *info = this_thread_info;
    *info->enqueue_reporter = true;
    atomic_fetch_add_explicit(info->enqueue_counter, 1, memory_order_release);
}

int main() {
    int num_tables[5];
    for(int i = 0; i < 5; ++i) {
        scanf("%d", &num_tables[i]);
    }
    restaurant_init(num_tables);

    cmdlist *cmds = NULL;
    groupinfo *real_eating_list = NULL;
    groupinfo *eating_list = NULL;
    pthread_mutex_t eating_mutex;
    pthread_mutex_init(&eating_mutex, NULL);

    while (1) {
        int res;
        while (1) {
            char str[1024];
            res = scanf(" %1023s", str);
            if (res < 1 || strcmp(str, ".") == 0) break;
            cmd_type type;
            if (strcmp(str, "Enter") == 0) type = CMD_ENTER;
            else if (strcmp(str, "Leave") == 0) type = CMD_LEAVE;
            else {
                fprintf(stderr, "Invalid command \"%s\"!\n", str);
                abort();
            }
            cmdlist *new_cmd = malloc(sizeof(cmdlist));
            assert_malloc_succeeded(new_cmd);
            int id;
            scanf("%d", &id);
            new_cmd->type = type;
            new_cmd->group_id = id;
            if (type == CMD_ENTER) {
                int size;
                scanf("%d", &size);
                if (size < 1 || size > 5) {
                    fprintf(stderr, "Invalid group size \"%d\"!\n", size);
                    abort();
                }
                new_cmd->enter_data.group_size = size;
            }
            new_cmd->next = cmds;
            cmds = new_cmd;
        }
        atomic_uint enqueue_counter;
        atomic_init(&enqueue_counter, 0);
        unsigned num_threads = cmdlist_size(cmds);
        unsigned expected_num_enqueued = 0;
        if (num_threads) {
            // these stuff to help ensure that threads start at the same time,
            // in the hope of triggering some race conditions.
            busywaiter waiter;
            busywaiter_init(&waiter);

            for (cmdlist *it = cmds; it; it = it->next) {
                switch (it->type) {
                    case CMD_ENTER: {
                        groupinfo *info = malloc(sizeof(groupinfo));
                        assert_malloc_succeeded(info);
                        info->group_id = it->group_id;
                        info->group_size = it->enter_data.group_size;
                        info->waiter = &waiter;
                        it->enter_data.enqueued = false;
                        info->enqueue_reporter = &it->enter_data.enqueued;
                        info->enqueue_counter = &enqueue_counter;
                        info->eating_list = &eating_list;
                        info->eating_mutex = &eating_mutex;
                        int err;
                        if ((err = pthread_create(&(info->thread), NULL, &run_group, info))) {
                            fprintf(stderr, "pthread_create() failed: %d\n", err);
                            abort();
                        }
                        printf("Group %d with %d people arrived\n", info->group_id, info->group_size);
                        ++expected_num_enqueued;
                        break;
                    }
                    case CMD_LEAVE: {
                        groupinfo *info = groupinfo_find_and_extract(&real_eating_list, it->group_id);
                        if (!info) {
                            // In this situation, the student code probably has a bug that caused our group to not get seated when it should have been.
                            printf("Test case wants group %d to leave, but this group is not currently seated... Test case failed\n", it->group_id);
                            return 0;
                        }
                        it->leave_data.info = info;
                        info->waiter = &waiter;
                        sem_post(&info->leave_sem);
                        break;
                    }
                    default: {
                        assert(false);
                    }
                }
            }
            busywaiter_main_wait(&waiter, num_threads);
            busywaiter_destroy(&waiter);
        }
        usleep(100000); // sleep for 100ms (during grading, we will wait for at least as many groups as we expect)
        while (atomic_load_explicit(&enqueue_counter, memory_order_acquire) != expected_num_enqueued); // wait until all groups are enqueued
        while (cmds) {
            switch (cmds->type) {
                case CMD_ENTER: {
                    if (!cmds->enter_data.enqueued) {
                        printf("Some other group called on_enqueue() twice, because group %d didn't call on_enqueue()... Test case failed\n", cmds->group_id);
                        return 0;
                    }
                    printf("Group %d is enqueued\n", cmds->group_id);
                    break;
                }
                case CMD_LEAVE: {
                    groupinfo *info = cmds->leave_data.info;
                    pthread_join(info->thread, NULL);
                    printf("Group %d left\n", info->group_id);
                    free(info);
                    break;
                }
                default: {
                    assert(false);
                }
            }
            cmdlist *tmp = cmds->next;
            free(cmds);
            cmds = tmp;
        }
        pthread_mutex_lock(&eating_mutex);
        while (eating_list) {
            printf("Group %d is seated at table %d\n", eating_list->group_id, eating_list->table_id);
            groupinfo *next_eating_list = eating_list->next;
            eating_list->next = real_eating_list;
            real_eating_list = eating_list;
            eating_list = next_eating_list;
        }
        pthread_mutex_unlock(&eating_mutex);
        if (res == EOF) break;
    }
    pthread_mutex_destroy(&eating_mutex);

    restaurant_destroy();
}
